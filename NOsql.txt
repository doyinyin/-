NoSQL 概述
数据库服务软件类型
RDBMS
• 关系数据库管理系统
– Relational Database Management System
– 数据按照预先设置的组织结构,存储在物理存储介质上。
– 数据之间可以做关联操作
RDBMS 服务软件
• 主流的 RDBMS 软件
– Oracle
– DB2
– WS-sqlserver
– MySQL
NoSQL
• NoSQL(NoSQL = Not Only SQL )
– 意思是 " 不仅仅是 SQL“
– 泛指非关系型数据库
– 不需要预先定义数据存储结构
– 表的每条记录都可以有不同的类型和结构NoSQL 服务软件
• 主流软件
– Redis
– MongoDB
– Memcached
– CouchDB
– Neo4j
– FlockDB
Redis 介绍
• Redis
– Remode DIctionary Server( 远程字典服务器 )
– 使用 C 语言编写的,遵守 BSD 的开源软件
– 是一款高性能的 (Key/Values) 分布式内存数据库
– 并支持数据持久化的 NoSQL 数据库服务软件
– 中文网站 www.redis.cn
• Redis 特点:
– 支持数据持久化,可以把内存里数据保存到硬盘中
– 不仅仅支持 key/values 类型的数据,同时还支持 list hash set zset 类型
– 支持 master-salve 模式数据备份
装包
• 安装源码包
#rpm -q gcc gcc-c++
# tar -xzf redis-4.0.8.tar.gz
# cd redis-4.0.8
#make
#make install
初始化配置
配置服务运行参数
– 端口
– 主配置文件
– 数据库目录
– pid 文件
– 启动程序
#./utils/install_server.sh // 初始化
/etc/redis/6379.conf   默认配置文件
ss -untlp |grep :6379
ps -C redis-server
修改服务使用的ip地址和端口号
/etc/init.d/redis_6379  stop
vim /etc/redis/6379.conf
 bind 192.168.4.5
 post 6351
:wq
/etc/init.d/redis_6379  start   启动服务
/etc/init.d/redis_6379  stop    停止服务
redis-cli  -h 192.168.4.51 -p 6351 shutdown  //修改后停止服务
vim /etc/init.d/redis_6379    //通过修改脚本去执行停止
 $CLIEXEC -h 192.168.4.51 -p $REDISPORT shutdown
:wq
连接 Redis 服务
• 访问 redis 服务
– ps -C redis
– netstat -utnlp | grep redis
– redis-cli
// 连接本机 redis 服务
常用操作指令
– Set keyname keyvalue // 存储
– get keyname // 获取
– Select 数据库编号 0-15 // 切换库
– Keys * // 打印所以变量
– Keys a? // 打印指定变量
– Exists keyname // 测试是否存在
– ttl keyname   // 查看生存时间
– type keyname // 查看类型
– move keyname dbname // 移动变量
– expire keyname 10 // 设置有效时间
– del keyname // 删除变量
– flushall // 删除所有变量
– save // 保存变量
– shutdown // 关闭服务
-2 过期
-1 永不过期
配置文件解析
数据单位
# 1k => 1000 bytes
# 1kb => 1024 bytes
# 1m => 1000000 bytes
# 1mb => 1024*1024 bytes
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes
常用配置选项
– port 6379 // 端口
– bind 127.0.0.1 //IP 地址
– tcp-backlog 511 //tcp 连接总数
– timeout 0 // 连接超时时间
– tcp-keepalive 300 // 长连接时间
– daemonize yes // 守护进程方式运行
– databases 16 // 数据库个数
– logfile /var/log/redis_6379.log //pid 文件
– maxclients 10000 // 并发连接数量
– dir /var/lib/redis/6379 // 数据库目录
内存管理
• 内存清除策略
– volatile-lru 最近最少使用 (针对设置了过期时间的 key )
– allkeys-lru 删除最少使用的 key
– volatile-random 在设置了过期的 key 里随机移除
– allkeys-random 随机移除 key
– volatile-ttl (minor TTL) 移除最近过期的 key
– noeviction 不删除 写满时报错
• 选项默认设置
– maxmemory <bytes> // 最大内存
– maxmemory-policy noeviction // 定义使用的策略
– maxmemory-samples 5 // 选取模板数据的个数(针对 lru 和 ttl 策略)
设置连接密码
• 设置密码
– grep -n requirepass /etc/redis/6379.conf
501:requirepass 123456
– [root@localhost redis-4.0.8]# redis-cli
– 127.0.0.1:6379> ping
– (error) NOAUTH Authentication required.
– 127.0.0.1:6379> auth 123456 // 输入密码
– OK
– 127.0.0.1:6379> ping
– PONG
– 127.0.0.1:6379>
部署 LNMP+Redis
rpm -q httpd mariadb-server   php mariadb   php-mysql
]# rpm -qa  | grep -i  mysql
]# systemctl  start httpd ; systemctl  enable httpd
]# systemctl  start mysqld ; systemctl  enable mysqld
~]# mysql -uroot -p123456
mysql>
LNMP:
安装源码nginx
    rpm -q gcc  gcc-c++  pcre-devel  zlib-devel
    useradd nginx
    ./configure --prefix=/usr/local/nginx  --user=nginx --group=nginx 
    make
    make install
    ls /usr/local/nginx/
 ]# netstat -utnlp  | grep :80
 ]# /usr/local/nginx/sbin/nginx 
 ]# netstat -utnlp  | grep :80
tcp     0   0 0.0.0.0:80       0.0.0.0:*        LISTEN      3130/nginx: master  
 ]# echo 234 > /usr/local/nginx/html/a.html
 ]# curl http://localhost/a.html
安装fastcgi
]# rpm -ivh php-fpm-5.4.16-42.el7.x86_64.rpm
]# systemctl  start php-fpm.service 
]# systemctl  enable php-fpm.service 
]# netstat -utnlp  | grep :9000
vim   /usr/local/nginx/conf/nginx.conf
 65         location ~ \.php$ {
 66             root           html;
 67             fastcgi_pass   127.0.0.1:9000;
 68             fastcgi_index  index.php;
 69         #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
 70         #    include        fastcgi_params;
 71             include        fastcgi.conf;
 72         }
:wq
]# /usr/local/nginx/sbin/nginx  -s stop
]# /usr/local/nginx/sbin/nginx
]# vim /usr/local/nginx/html/test.php
]# curl http://localhost/test.php
php支持redis服务 51  LNMP
配置步骤：
1  装包
]#rpm -q gcc  gcc-c++
]#yum -y install autoconf automake
]#rpm php-devel-5.4.16-42.el7.x86_64.rpm 
]#tar -zxvf php-redis-2.2.4.tar.gz 
]#cd phpredis-2.2.4/
]#phpize
]#./configure  --with-php-config=/usr/bin/php-config   
]#make
]#make install
]#ls /usr/lib64/php/modules/
2  修改PHP程序的配置文件，调用模块。
]# vim /etc/php.ini     
 extension_dir = "/usr/lib64/php/modules/"
 extension = "redis.so"
:wq
]# systemctl  restart php-fpm.service
]# php -m  | grep  -i   redis
redis
3 编写php脚本（连接redis服务存储数据）
vim /usr/local/nginx/html/redis.php
<?php
$redis = new redis();
$redis->connect('192.168.4.51',"6351");
$redis->auth('123456');
$redis->set('school','tearena');
echo $redis->get('school');
?>
:wq
4 测试配置
4.1  在客户端访问51 网站服务器的redis.php 网页文件
4.2  连接51主机的redis服务查看存储数据是否有名叫school的变量名。
• 安装源码 nginx 和 PHP
yum -y install gcc gcc-c++ pcre-devel zlib-devel
tar -zxf nginx-1.12.2.tar.gz
]# cd nginx-1.12.2
]# ./configure --prefix=/usr/local/nginx
]# make
]# make install
 yum -y install php-common
 rpm -ivh php-fpm-5.4.16-42.el7.x86_64.rpm
########################################
创建 Redis 集群
装包
• 在 6 台主机上做如下配置,并运行 redis 服务
#yum -y install gcc gcc-c++
#tar -zxvf redis-4.0.8.tar.gz
#cd redis-4.0.8/
#make
#make install
#./utils/install_server.sh
• 修改配置文件
#vim /etc/redis/redis.conf
bind IP 地址  // 只写物理接口 IP 地址
daemonize yes // 守护进程方式运行
port xxxx  // 端口号不要使用默认的 6379
cluster-enabled yes  // 开启集群
cluster-config-file nodes.conf // 集群的配置文件不要使用默认的名称
cluster-node-timeout 5000 // 请求超时 5 秒
创建集群
#yum -y install ruby rubygems
#rpm -ivh --nodeps ruby-devel-2.0.0.648-30.el7.x86_64.rpm
#gem install redis-3.2.1.gem
#cd redis-3.2.0/src/
#./redis-trib.rb create --replicas 1  192.168.4.51:6351  192.168.4.52:6352192.168.4.53:6353 192.168.4.54:6354 192.168.4.55:6355 192.168.4.56:6356
查看集群信息
• 任意一台主机访问本机的 redis 服务,查看即可
– redis-cli -c -h IP 地址
> cluster nodes # 查看本机信息
> cluster info
# 查看集群信息
-p 端口
测试集群
• 在其中任意一台上存储数据 ,在其他任意一台上都可以获取数据。
存数据 set name jerry
取数据 get name
redis-cli 命令
• 查看命令帮助
– redis-cli -h
• 常用选项
– -h IP 地址
– -p 端口
– -c 访问集群
redis-trib.rb 脚本
• 语法格式
– Redis-trib.rb  选项 参数
• 选项
– add-node 添加新节点
– check 对节点主机做检查
– reshard 对节点主机重新分片
– add-node --slave 添加从节点主机
– del-node 删除节点主机
集群节点选举测试
如何选举 master 主机
• 把是 master 角色主机上的 Redis 服务 停止
#redis-cli -h ip -p 端口 shutdown
• 对应是 slave 角色主机 是否能自动升级为 master
> cluster status
注意: 原先是 master 服务启动后身份是当前 master 的 slave
添加新节点
默认新主机被选为主
• 新主机做集群配置,并运行 redis 服务
• 将新主机添加到集群中
– # ./redis-trib.rb add-node 新主机 Ip: 端口 192.168.4.51:6351
• 手动对集群进行重新分片
– src]# ./redis-trib.rb reshard 192.168.4.51:6351
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
How many slots do you want to move (from 1 to 16384)? 4096
What is the receiving node ID? c7ba3b3156fa9148f1cf764f6053cea0bb295d8b
Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1:all	
• 查看分配的槽位
– src]# ./redis-trib.rb check 192.168.4.51:6351
添加从节点
• 对添加为从节点的主机做如下配置
– 装包 修改配置文件 启动 redis 服务
• 添加从节点
# ./redis-trib.rb add-node --slave --master-id id 值从节点 ip: 端口 192.168.4.51:6351
如果不指定主节点的 id 的话,会把新节点 随机添加为 从节点 最少的主的从
移除节点
移除主节点
• 删除槽位
• ~]# redis-trib.rb reshard 192.168.4.51:6351
How many slots do you want to move (from 1 to 16384)? 4096
What is the receiving node ID? c7ba3b3156fa9148f1cf764f6053cea0bb295d8b
Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1:a88338a9d23a80b65cc0a125548b02946d13e7a6
Source node #2:done
• 移除主节点
]# redis-trib.rb del-node 192.168.4.51:6351 被移除节点主机 id
移除从节点
• 从节点主机没有槽位范围,直接执行移除命令即可
– redis-trib.rb del-node 192.168.4.51:6351 被移除主机的 ID
redis-trib.rb 脚本 选项总结
• redis-trib.rb 选项
create 创建集群
check 检查集群
reshard 重新分片
del-node 删除集群主机
--slave 添加 slave 主机
add-node 添加新节点主机
再次添加已添加过的主机
cluster  reset  //还原成没有加入集群的状态
       加入集群并给与槽
#########################################################
主从复制
主从复制结构模式
结构模式
– 一主一从
– 一主多从
– –主从从
主从复制工作原理
• 工作原理
– Slave 向 maste 发送 sync 命令
– Master 启动后台存盘进程,同时收集所有修改数据命令
– Master 执行完后台存盘进程后,传送整个数据文件到slave 。
– Slave 接收数据文件后,将其存盘并加载到内存中完成首次完全同步
– 后续有新数据产生时, master 继续将新的所以收集到的修改命令依次传给 slave ,完成同步。
主从复制缺点
• 缺点
– 网络繁忙,会产生数据同步延时问题
– 系统繁忙,会产生数据同步延时问题
配置从库
• 配置从库 192.168.4.52/24
– redis 服务运行后,默认都是 master 服务器
– 修改服务使用的 IP 地址 bind 192.168.4.X
       redis-cli -h 192.168.4.52
192.168.4.52:6379> info replication // 查看主从配置信息
       SLAVEOF 192.168.4.51 6379
命令行指定主库
SLAVEOF 主库 IP 地址 端口号
反客为主
– 主库宕机后,手动将从库设置为主库
SLAVEOF no one // 设置为主库
哨兵模式
• 哨兵模式
– 主库宕机后,从库自动升级为主库
– 在 slave 主机编辑 sentinel.conf 文件
– 在 slave 主机运行哨兵程序
vim /etc/sentinel.conf
sentinel monitor redis51 192.168.4.51 6379 1
sentinel auto-pass host51 123456
:wq
redis-sentinel /etc/sentinel.conf
sentinel monitor 主机名 ip 地址 端口 票数 
主机名:自定义
IP 地址: master 主机的 IP 地址
端 口: master 主机 redis 服务使用的端口
票 数:主库宕机后, 票数大于 1 的主机被升级为主库
配置带验证的主从复制
• 配置 master 主机
– 设置连接密码 ,启动服务,连接服务
sed -n '70p;501p' /etc/redis/6379.conf
bind 192.168.4.51
requirepass 123456 // 密码
/etc/init.d/redis_6379 start
redis-cli -h 192.168.1.111 -a 123456 -p 6379
• 配置 slave 主机
– 指定主库 IP ,设置连接密码,启动服务
sed -n '70p;282p;289p' /etc/redis/6379.conf
bind 192.168.4.52
slaveof 192.168.4.51 6379 // 主库 IP 与端口
masterauth 123456 // 主库密码
/etc/init.d/redis_6379 start
redis-cli -h 192.168.4.52
192.168.4.52:6379> INFO replication
# Replication
role:slave
master_host:192.168.4.51
master_port:6379
############################################
Redis 持久化 RDB/AOF
持久化之 RDB
RDB 介绍
• 全称 Reids DataBase
– 数据持久化方式之一
– 在指定时间间隔内,将内存中的数据集快照写入硬盘。
– 术语叫 Snapshot 快照。
– 恢复时,将快照文件直接读到内存里
相关配置参数
• 文件名
– dbfilename “dump.rdb” // 文件
– save “”   // 禁用 RDB
• 数据从内存保存到硬盘的频率
– save 900 1     // 900 秒内且有 1 次修改存盘
– save 300 10    //300 秒内且有 10 次修改存盘
– save 60 10000  //60 秒内且有 10000 修改存盘
• 手动立刻存盘
– > save   // 阻塞写存盘
– > bgsave // 不阻塞写存盘
• 压缩
– rdbcompression yes | no
• 在存储快照后,使用 crc16 算法做数据校验
– rdbchecksum yes|no
• bgsave 出错停止写操作 , 对数据一致性要求不高设置为 no
– stop-writes-on-bgsave-error yes|no
使用 RDB 文件恢复数据
• 备份数据
– 备份 dump.rdb 文件到其他位置
– ~]# cp 数据库目录 /dump.rdb
备份目录
• 恢复数据
– 把备份的 dump.rdb 文件拷贝回数据库目录 , 重启 redis 服务
– cp 备份目录 /dump.rdb 数据库目录 /
– /etc/redid/redis_ 端口 start
RDB 优点 / 缺点
• RDB 优点
– 持久化时, Redis 服务会创建一个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件;整个过程中主进程不做任何 IO 操作,这就确保了极高的性能。
– 如果要进程大规模数据恢复,且对数据完整行要求不
是非常高,使用 RDB 比 AOF 更高效。
• RDB 的缺点
– 意外宕机,最后一次持久化的数据会丢失。
持久化之 AOF
AOF 介绍
• 只追加操作的文件
– Append Only File
– 记录 redis 服务所有写操作。
– 不断的将新的写操作,追加到文件的末尾。
– 使用 cat 命令可以查看文件内容
相关配置参数
• 文件名
– appendfilename "appendonly.aof" // 文件名
– appendonly yes // 启用 aof ,默认 no
• AOF 文件记录,写操作的三种方式
– appendfsync always // 有新的写操作立即记录,性能差,完整性好。
– appendfsync everysec // 每秒记录一次,宕机时会丢失 1 秒的数据
– appendfsync no        // 从不记录
• 日志重写 ( 日志文件会不断增大 ) ,何时会触发日志重写?
– redis 会记录上次重写时 AOF 文件的大小,默认配置是当 aof 文件是上次 rewrite 后大小的 1 倍且文件大于64M 时触发。
– auto-aof-rewrite-percentage 100
– auto-aof-rewrite-min-size 64mb
• 修复 AOF 文件,
– 把文件恢复到最后一次的正确操作
redis-check-aof --fix appendonly.aof
• 备份数据
– 备份 dump.rdb 文件到其他位置
– ~]# cp 数据库目录 /appendonly.aof
备份目录
• 恢复数据
– 把备份的 dump.rdb 文件拷贝回数据库目录 , 重启 red
is 服务
– Cp 备份目录 /appendonly.aof   数据库目录 /
– /etc/redid/redis_ 端口 start
AOF 优点 / 缺点
• RDB 优点
– 可以灵活的设置同步持久化 appendfsync alwayls 或异步持久化 appendfsync verysec
– 宕机时,仅可能丢失 1 秒的数据
• RDB 的缺点
– AOF 文件的体积通常会大于 RDB 文件的体积。执行 fsync 策略时的速度可能会比 RDB 慢。
优先启动AOF
########################################################3
数据类型
字符串操作
• set key value [ex seconds] [px milliseconds] [nx|xx]
– 设置 key 及值,过期时间可以设置为秒或毫秒为单位
– nx 只有 key 不存在,才对 key 进行操作
– xx 只有 key 已存在,才对 key 进行操作
• setrange key offset value
– 从偏移量开始复写 key 的特定位的值
>set first "hello world"
>setrange first 6 “Redis”
• strlen key
– 统计字串长度
>strlen first
• append key value
– 字符存在则追加,不存在则创建 key 及 value
– 返回值为 key 的长度
>append myname jacob
• setbit key offset value
– 对 key 所存储字串,设置或清除特定偏移量上的位 (bi
t)
– Value 值可以为 1 或 0 , offset 为 0~2^32 之间
– key 不存在,则创建新 key
>setbit bit 0 1
>setbit bit 1 0
bit: 第 0 位为 1 ,第一位为 0
• bitcount key
– 统计字串中被设置为 1 的比特位数量
>setbit bits 0 1
//0001
>setbit bits 3 1
//1001
>bitcount bits
// 结果为 2
记录网站用户上线频率,如用户 A 上线了多少天等类似的数据
如用户在某天上线,则使用 setbit ,以用户名为 key ,将网站上线
日为 offset ,并在该 offset 上设置 1 ,最后计算用户总上线次数时
,使用 bitcount 用户名即可
这样,即使网站运行 10 年,每个用户仅占用 10*365 比特位即 456
字节即可
>setbit peter 100 1 // 网站上线 100 天用户登录了一次
>setbit peter 105 1 // 网站上线 105 天用户登录了一次
>bitcount peter
• decr key
– 将 key 中的值减 1 , key 不存在则先初始化为 0 ,再减 1
>set test 10
>decr test
• decrby key decrement
– 将 key 中的值,减去 decrement
>set count 100
>decrby count 20
• get key
– 返回 key 所存储的字符串值
– 如果 key 不存在则返回特殊值 nil
– 如果 key 的值不是字串,则返回错误, get 只能处理字串
• getrange key start end
– 返回字串值中的子字串,截取范围为 start 和 end
– 负数偏移量表述从末尾计数, -1 表示最后一个字符, -2表示倒数第二个字符
>set first “hello,the world”
>getrange first -5 -1
>getrange first 0 4
• incr key
– 将 key 的值加 1 ,如果 key 不存在,则初始为 0 后再加 1
– 主要应用为计数器
>set page 20
>incr page
• incrby key increment
– 将 key 的值增加 increment
• incrbyfloat key increment
– 为 key 中所储存的值加上浮点数增量 increment
>set num 16.1
>incrbyfloat num 1.1
• mget key [key...]
– 一次获取一个或多个 key 的值,空格分隔, < 具有原子性>
• mset key value [key value ...]
– 一次设置多个 key 及值,空格分隔, < 具有原子性 >
#############################33
Hash 表
• Redis hash 是一个 string 类型的 field 和 value 的映射表
• 一个 key 可对应多个 field ,一个 field 对应一个 value
• 将一个对象存储为 hash 类型,较于每个字段都存储成string 类型更能节省内存
• hmset key field value [field value...]
– 同时给 hash 表中的多个 field 赋值
>hmset site google www.g.cn baidu www.baidu.com
• hmget key field [field...]
– 返回 hash 表中多个 field 的值
>hmget site google baidu
• hkeys key
– 返回 hash 表中所有 field 名称
>hmset site google www.g.cn baidu www.baidu.com
>hkeys site
• hgetall key
– 返回 hash 表中所有 field 的值
• hvals key
– 返回 hash 表中所有 filed 的值
>hvals key
• hdel key field [field...]
– 删除 hash 表中多个 field 的值,不存在则忽略
>hdel site google baidu
List 列表
• Redis 的 list 是一个字符队列
• 先进后出
• 一个 key 可以有多个值
• lpush key value [value...]
– 将一个或多个值 value 插入到列表 key 的表头
– Key 不存在,则创建 key
>lpush list a b c //list1 值依次为 c b a
等同于 lpush list a; lpush list b; lpush list c
• lrange key start stop
– 从开始位置读取 key 的值到 stop 结束
>lrange list 0 2     // 从 0 位开始,读到 2 位为止
>lrange list 0 -1    // 从开始读到结束为止
>lrange list 0 -2    // 从开始读到倒数第 2 位值
• lpop key
– 移除并返回列表头元素数据, key 不存在则返回 nil
>lpop list      // 删除表头元素,可以多次执行
• llen key
– 返回列表 key 的长度
• lindex key index
– 返回列表中第 index 个值
• lset key index value
– 将 key 中 index 位置的值修改为 value
• rpush key value [value...]
– 将 value 插入到 key 的末尾
• rpop key
– 删除并返回 key 末尾的值
– >rpush list3 a b c //list3 值为 a b c
其他操作
• del key [key...]
– 删除一个或多个 key
• exists key
– 测试一个 key 是否存在
• expire key seconds
– 设置 key 的生存周期
• persist key
– 设置 key 永不过期
• ttl key
– 查看 key 的生存周期
• keys 匹配
– 找符合匹配条件的 key ,特殊符号用 \ 屏蔽
• flushall
– 清空所有数据
• select id
– 选择数据库, id 用数字指定,默认数据库为 0
• move key db_id
– 将当前数据库的 key 移动到 db_id 数据库中
• rename key newkey
– 给 key 改名为 newkey , newkey 已存在时,则覆盖其值
• renamenx key newkey
– 仅当 newkey 不存在时,才将 key 改名为 newkey

